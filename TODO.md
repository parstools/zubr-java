* field fastIndex and updateFastIndex after grammar creation and modification, before sorting by index
* tail recursion (for example A-> a A) , but some cases need recursion: unary minus
* elimination chain nonterminals: if A -> A1 is only rule
* create LL(1) table
* create LL(k) table
* input/EBNF (option preferRightRecursion), input/Dat
* target/Java